C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 22:45:14 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE DISPLAY
OBJECT MODULE PLACED IN .\Objects\display.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE display.c ROM(COMPACT) OPTIMIZE(8,SPEED) PRINT(.\Listings\display.lst) T
                    -ABS(2) OBJECT(.\Objects\display.obj)

line level    source

   1          #include "display.h"
   2          #include "clock.h"
   3          #include "stopwatch.h"
   4          #include "state.h"
   5          #include <reg51.h>
   6          
   7          /* 外部变量和原始数据 */
   8          extern bit g_menu_cursor_visible;
   9          
  10          typedef struct
  11          {
  12              unsigned char top[16];
  13              unsigned char bottom[16];
  14          } Hanzi16;
  15          
  16          static const Hanzi16 code g_hanzi_table[] = {
  17              {// "秒"
  18               {0x24, 0x24, 0xA4, 0xFE, 0x23, 0x22, 0x00, 0xC0, 0x38, 0x00, 0xFF, 0x00, 0x08, 0x10, 0x60, 0x00},
  19               {0x08, 0x06, 0x01, 0xFF, 0x01, 0x06, 0x81, 0x80, 0x40, 0x40, 0x27, 0x10, 0x0C, 0x03, 0x00, 0x00}},
  20              {// "表"
  21               {0x00, 0x04, 0x24, 0x24, 0x24, 0x24, 0x24, 0xFF, 0x24, 0x24, 0x24, 0x24, 0x24, 0x04, 0x00, 0x00},
  22               {0x21, 0x21, 0x11, 0x09, 0xFD, 0x83, 0x41, 0x23, 0x05, 0x09, 0x11, 0x29, 0x25, 0x41, 0x41, 0x00}}};
  23          
  24          enum
  25          {
  26              HANZI_MIAO = 0,
  27              HANZI_BIAO = 1
  28          };
  29          
  30          #define DISPLAY_SCREEN_NONE 0xFF
  31          #define DISPLAY_SCREEN_HOME 0
  32          #define DISPLAY_SCREEN_STOPWATCH 2
  33          #define DISPLAY_SCREEN_LAP 2
  34          
  35          /* 静态全局变量 */
  36          static unsigned char idata g_last_screen = DISPLAY_SCREEN_NONE;
  37          static bit g_stopwatch_initialized = 0;
  38          static unsigned char idata g_prev_stop_hour = 0xFF;
  39          static unsigned char idata g_prev_stop_minute = 0xFF;
  40          static unsigned char idata g_prev_stop_second = 0xFF;
  41          static unsigned char idata g_prev_stop_decisecond = 0xFF;
  42          static unsigned char idata g_prev_lap_index[3] = {0xFF, 0xFF, 0xFF};
  43          static unsigned char idata g_prev_lap_hour[3];
  44          static unsigned char idata g_prev_lap_minute[3];
  45          static unsigned char idata g_prev_lap_second[3];
  46          static unsigned char idata g_prev_lap_decisecond[3];
  47          static unsigned char idata g_prev_menu_pos = 0xFF;
  48          
  49          //基础绘制函数
  50          static void Display_Hanzi16(unsigned char page, unsigned char col, unsigned char index)
  51          {
  52   1          unsigned char i;
  53   1          for (i = 0; i < 16; i++)
  54   1          {
C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 22:45:14 PAGE 2   

  55   2              LCD_DrawByte(page, col + i, g_hanzi_table[index].top[i]);
  56   2              LCD_DrawByte(page + 1, col + i, g_hanzi_table[index].bottom[i]);
  57   2          }
  58   1      }
  59          
  60          static void Display_DrawMenuCursor(unsigned char line, bit visible)
  61          {
  62   1          // 优化: 合并变量声明，减少行数
  63   1          unsigned char base_page, total_width, time_col, i, col;
  64   1      
  65   1          base_page = (line == 0) ? 0 : ((line == 1) ? 3 : 6);
  66   1      
  67   1          /* 计算光标位置 */
  68   1          {
  69   2              total_width = 16 + (8 - 1) * 12; // 100
  70   2              time_col = (128 - total_width) / 2;
  71   2              col = (time_col > 10) ? (time_col - 10) : 0;
  72   2          }
  73   1      
  74   1          if (visible)
  75   1          {
  76   2              /* 绘制箭头 */
  77   2              static const unsigned char code arrow_bottom[8] = {
  78   2                  0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01};
  79   2              static const unsigned char code arrow_top[8] = {
  80   2                  0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80};
  81   2              for (i = 0; i < 8; i++)
  82   2              {
  83   3                  LCD_DrawByte(base_page, col + i, arrow_top[i]);
  84   3                  LCD_DrawByte(base_page + 1, col + i, arrow_bottom[i]);
  85   3              }
  86   2          }
  87   1          else
  88   1          {
  89   2              // 清除箭头
  90   2              LCD_ClearArea(base_page, base_page + 1, col, col + 7);
  91   2          }
  92   1      }
  93          
  94          static void Display_Char_8x16_Custom(unsigned char page, unsigned char col, char c, bit underline)
  95          {
  96   1          unsigned char i, index = GetCharIndex(c), data_byte;
  97   1          for (i = 0; i < 8; i++)
  98   1          {
  99   2              data_byte = Font_8x16[index][i];
 100   2              LCD_DrawByte(page, col + i, data_byte);
 101   2              data_byte = Font_8x16[index][i + 8];
 102   2              if (underline)
 103   2              {
 104   3                  data_byte |= 0x80;
 105   3              }
 106   2              LCD_DrawByte(page + 1, col + i, data_byte);
 107   2          }
 108   1      }
 109          
 110          static void Display_Char_16x16_Custom(unsigned char page, unsigned char col, char c, bit underline)
 111          {
 112   1          unsigned char i, index = GetCharIndex(c), data_byte;
 113   1          for (i = 0; i < 16; i++)
 114   1          {
 115   2              data_byte = Font_16x16[index][i];
 116   2              LCD_DrawByte(page, col + i, data_byte);
C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 22:45:14 PAGE 3   

 117   2              data_byte = Font_16x16[index][i + 16];
 118   2              if (underline)
 119   2              {
 120   3                  data_byte |= 0x80;
 121   3              }
 122   2              LCD_DrawByte(page + 1, col + i, data_byte);
 123   2          }
 124   1      }
 125          
 126          /* 公共接口 */
 127          void Display_Char_8x16(unsigned char page, unsigned char col, char c)
 128          {
 129   1          Display_Char_8x16_Custom(page, col, c, 0);
 130   1      }
 131          
 132          void Display_Char_16x16(unsigned char page, unsigned char col, char c)
 133          {
 134   1          Display_Char_16x16_Custom(page, col, c, 0);
 135   1      }
 136          
 137          /* 绘制秒表的小数点 */
 138          static void Display_DrawDecimalPoint(unsigned char page, unsigned char col)
 139          {
 140   1          unsigned char idata i;
 141   1          for (i = 0; i < 8; i++)
 142   1          {
 143   2              LCD_DrawByte(page, col + i, 0x00);
 144   2              LCD_DrawByte(page + 1, col + i, (i == 3 || i == 4) ? 0x18 : 0x00);
 145   2          }
 146   1      }
 147          
 148          /* 绘制一行计次时间 (HH:MM:SS.D) (复用于 StopwatchPage 和 LapViewPage) */
 149          static void Display_DrawLapTime(unsigned char page, unsigned char base_col, unsigned char lap_index)
 150          {
 151   1          Display_Char_8x16(page, base_col + 0, g_laps[lap_index].hour / 10 + '0');
 152   1          Display_Char_8x16(page, base_col + 8, g_laps[lap_index].hour % 10 + '0');
 153   1          Display_Char_8x16(page, base_col + 16, ':');
 154   1          Display_Char_8x16(page, base_col + 24, g_laps[lap_index].minute / 10 + '0');
 155   1          Display_Char_8x16(page, base_col + 32, g_laps[lap_index].minute % 10 + '0');
 156   1          Display_Char_8x16(page, base_col + 40, ':');
 157   1          Display_Char_8x16(page, base_col + 48, g_laps[lap_index].second / 10 + '0');
 158   1          Display_Char_8x16(page, base_col + 56, g_laps[lap_index].second % 10 + '0');
 159   1          Display_DrawDecimalPoint(page, base_col + 64); /* 复用 */
 160   1          Display_Char_8x16(page, base_col + 72, g_laps[lap_index].decisecond + '0');
 161   1      }
 162          
 163          /* 重置指定索引的 "上一次" 计次缓存 */
 164          static void Display_ResetPrevLap(unsigned char i)
 165          {
 166   1          g_prev_lap_index[i] = 0xFF;
 167   1          g_prev_lap_hour[i] = 0xFF;
 168   1          g_prev_lap_minute[i] = 0xFF;
 169   1          g_prev_lap_second[i] = 0xFF;
 170   1          g_prev_lap_decisecond[i] = 0xFF;
 171   1      }
 172          
 173          /* 重置所有 "上一次" 的秒表和计次缓存变量 (复用于 ResetStopwatch 和 StopwatchPage) */
 174          static void Display_Internal_ResetStopwatchVars(void)
 175          {
 176   1          unsigned char idata i;
 177   1          g_prev_stop_hour = 0xFF;
 178   1          g_prev_stop_minute = 0xFF;
C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 22:45:14 PAGE 4   

 179   1          g_prev_stop_second = 0xFF;
 180   1          g_prev_stop_decisecond = 0xFF;
 181   1          for (i = 0; i < 3; i++)
 182   1          {
 183   2              Display_ResetPrevLap(i); /* 复用 */
 184   2          }
 185   1      }
 186          
 187          /* 检查指定的计次是否需要更新 */
 188          static bit NeedLapUpdate(unsigned char i, unsigned char lap_index)
 189          {
 190   1          return (g_prev_lap_index[i] != lap_index) ||
 191   1                 (g_prev_lap_hour[i] != g_laps[lap_index].hour) ||
 192   1                 (g_prev_lap_minute[i] != g_laps[lap_index].minute) ||
 193   1                 (g_prev_lap_second[i] != g_laps[lap_index].second) ||
 194   1                 (g_prev_lap_decisecond[i] != g_laps[lap_index].decisecond);
 195   1      }
 196          
 197          /* 更新 "上一次" 计次缓存为当前值 */
 198          static void Display_SetPrevLap(unsigned char i, unsigned char lap_index)
 199          {
 200   1          g_prev_lap_index[i] = lap_index;
 201   1          g_prev_lap_hour[i] = g_laps[lap_index].hour;
 202   1          g_prev_lap_minute[i] = g_laps[lap_index].minute;
 203   1          g_prev_lap_second[i] = g_laps[lap_index].second;
 204   1          g_prev_lap_decisecond[i] = g_laps[lap_index].decisecond;
 205   1      }
 206          
 207          // 主显示函数
 208          void Display_HomePage(void)
 209          {
 210   1          // 优化: 合并变量声明，减少行数
 211   1          unsigned int year_display;
 212   1          unsigned char month_display, day_display, total_width, date_highlight;
 213   1          unsigned char hour_display, minute_display, second_display;
 214   1          bit editing_date, editing_time, menu_active, first_draw;
 215   1          bit highlight_hour_tens, highlight_hour_units, highlight_minute_tens;
 216   1          bit highlight_minute_units, highlight_second_pair;
 217   1          unsigned char page, col;
 218   1      
 219   1          first_draw = (g_last_screen != DISPLAY_SCREEN_HOME);
 220   1          g_last_screen = DISPLAY_SCREEN_HOME;
 221   1      
 222   1          if (first_draw)
 223   1          {
 224   2              LCD_ClearArea(0, 7, 0, 127);
 225   2          }
 226   1      
 227   1          // 状态计算
 228   1          editing_date = (g_system_state == STATE_DATE_SET);
 229   1          editing_time = (g_system_state == STATE_TIME_SET);
 230   1          menu_active = (g_system_state == STATE_MENU);
 231   1      
 232   1          if (editing_date)
 233   1          {
 234   2              year_display = g_temp_year;
 235   2              month_display = g_temp_month;
 236   2              day_display = g_temp_day;
 237   2              date_highlight = 7 - g_edit_pos;
 238   2          }
 239   1          else
 240   1          {
C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 22:45:14 PAGE 5   

 241   2              year_display = g_datetime.year;
 242   2              month_display = g_datetime.month;
 243   2              day_display = g_datetime.day;
 244   2          }
 245   1      
 246   1          if (editing_time)
 247   1          {
 248   2              hour_display = g_temp_hour;
 249   2              minute_display = g_temp_minute;
 250   2              second_display = g_temp_second;
 251   2          }
 252   1          else
 253   1          {
 254   2              hour_display = g_datetime.hour;
 255   2              minute_display = g_datetime.minute;
 256   2              second_display = g_datetime.second;
 257   2          }
 258   1      
 259   1          highlight_hour_tens = editing_time && (g_edit_pos == 5);
 260   1          highlight_hour_units = editing_time && (g_edit_pos == 4);
 261   1          highlight_minute_tens = editing_time && (g_edit_pos == 3);
 262   1          highlight_minute_units = editing_time && (g_edit_pos == 2);
 263   1          highlight_second_pair = editing_time && (g_edit_pos == 0 || g_edit_pos == 1);
 264   1      
 265   1          // 日期绘制
 266   1          col = 24;
 267   1          Display_Char_8x16_Custom(0, col, (year_display / 1000) + '0', editing_date && date_highlight == 0);
 268   1          col += 8;
 269   1          Display_Char_8x16_Custom(0, col, ((year_display / 100) % 10) + '0', editing_date && date_highlight == 
             -1);
 270   1          col += 8;
 271   1          Display_Char_8x16_Custom(0, col, ((year_display / 10) % 10) + '0', editing_date && date_highlight == 2
             -);
 272   1          col += 8;
 273   1          Display_Char_8x16_Custom(0, col, (year_display % 10) + '0', editing_date && date_highlight == 3);
 274   1          col += 8;
 275   1          Display_Char_8x16(0, col, '-');
 276   1          col += 8;
 277   1          Display_Char_8x16_Custom(0, col, (month_display / 10) + '0', editing_date && date_highlight == 4);
 278   1          col += 8;
 279   1          Display_Char_8x16_Custom(0, col, (month_display % 10) + '0', editing_date && date_highlight == 5);
 280   1          col += 8;
 281   1          Display_Char_8x16(0, col, '-');
 282   1          col += 8;
 283   1          Display_Char_8x16_Custom(0, col, (day_display / 10) + '0', editing_date && date_highlight == 6);
 284   1          col += 8;
 285   1          Display_Char_8x16_Custom(0, col, (day_display % 10) + '0', editing_date && date_highlight == 7);
 286   1      
 287   1          // 时间绘制
 288   1          page = 3;
 289   1          {
 290   2              total_width = 16 + (8 - 1) * 12;
 291   2              col = (128 - total_width) / 2;
 292   2          }
 293   1          Display_Char_16x16_Custom(page, col, (hour_display / 10) + '0', highlight_hour_tens);
 294   1          col += 12;
 295   1          Display_Char_16x16_Custom(page, col, (hour_display % 10) + '0', highlight_hour_units);
 296   1          col += 12;
 297   1          Display_Char_16x16(page, col, ':');
 298   1          col += 12;
 299   1          Display_Char_16x16_Custom(page, col, (minute_display / 10) + '0', highlight_minute_tens);
 300   1          col += 12;
C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 22:45:14 PAGE 6   

 301   1          Display_Char_16x16_Custom(page, col, (minute_display % 10) + '0', highlight_minute_units);
 302   1          col += 12;
 303   1          Display_Char_16x16(page, col, ':');
 304   1          col += 12;
 305   1          Display_Char_16x16_Custom(page, col, (second_display / 10) + '0', highlight_second_pair);
 306   1          col += 12;
 307   1          Display_Char_16x16_Custom(page, col, (second_display % 10) + '0', highlight_second_pair);
 308   1      
 309   1          // 汉字绘制
 310   1          Display_Hanzi16(6, 48, HANZI_MIAO);
 311   1          Display_Hanzi16(6, 64, HANZI_BIAO);
 312   1      
 313   1          // 菜单光标绘制
 314   1          if (g_prev_menu_pos != 0xFF && (g_prev_menu_pos != g_menu_pos || !menu_active))
 315   1          {
 316   2              Display_DrawMenuCursor(g_prev_menu_pos, 0);
 317   2              g_prev_menu_pos = 0xFF; /* 标记为已清除 */
 318   2          }
 319   1          if (menu_active)
 320   1          {
 321   2              Display_DrawMenuCursor(0, g_menu_cursor_visible && (g_menu_pos == 0));
 322   2              Display_DrawMenuCursor(1, g_menu_cursor_visible && (g_menu_pos == 1));
 323   2              Display_DrawMenuCursor(2, g_menu_cursor_visible && (g_menu_pos == 2));
 324   2              g_prev_menu_pos = g_menu_pos; /* 记录绘制的位置 */
 325   2          }
 326   1      }
 327          
 328          void Display_ResetStopwatch(void)
 329          {
 330   1          g_stopwatch_initialized = 0;
 331   1          Display_Internal_ResetStopwatchVars(); // 复用: 重置所有g_prev_*变量
 332   1      }
 333          
 334          void Display_StopwatchPage(void)
 335          {
 336   1          // 优化: 合并变量声明，减少行数
 337   1          unsigned char idata hour, min, sec, ds, col, i, page, lap_index, lap_no;
 338   1          bit first_draw = (!g_stopwatch_initialized) || (g_last_screen != DISPLAY_SCREEN_STOPWATCH);
 339   1      
 340   1          if (first_draw)
 341   1          {
 342   2              LCD_ClearArea(0, 7, 0, 127);
 343   2              Display_Internal_ResetStopwatchVars(); /* 复用: 重置所有g_prev_*变量 */
 344   2              g_stopwatch_initialized = 1;
 345   2          }
 346   1          g_last_screen = DISPLAY_SCREEN_STOPWATCH;
 347   1      
 348   1          Stopwatch_GetTime(&hour, &min, &sec, &ds);
 349   1      
 350   1          // 主秒表绘制
 351   1          col = 16;
 352   1          if (first_draw || g_prev_stop_hour != hour)
 353   1          {
 354   2              Display_Char_8x16(0, col, hour / 10 + '0');
 355   2              Display_Char_8x16(0, col + 8, hour % 10 + '0');
 356   2              g_prev_stop_hour = hour;
 357   2          }
 358   1          Display_Char_8x16(0, col + 16, ':');
 359   1          if (first_draw || g_prev_stop_minute != min)
 360   1          {
 361   2              Display_Char_8x16(0, col + 24, min / 10 + '0');
 362   2              Display_Char_8x16(0, col + 32, min % 10 + '0');
C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 22:45:14 PAGE 7   

 363   2              g_prev_stop_minute = min;
 364   2          }
 365   1          Display_Char_8x16(0, col + 40, ':');
 366   1          if (first_draw || g_prev_stop_second != sec)
 367   1          {
 368   2              Display_Char_8x16(0, col + 48, sec / 10 + '0');
 369   2              Display_Char_8x16(0, col + 56, sec % 10 + '0');
 370   2              g_prev_stop_second = sec;
 371   2          }
 372   1      
 373   1          Display_DrawDecimalPoint(0, col + 64); // 复用: 绘制小数点
 374   1      
 375   1          if (first_draw || g_prev_stop_decisecond != ds)
 376   1          {
 377   2              Display_Char_8x16(0, col + 72, ds + '0');
 378   2              g_prev_stop_decisecond = ds;
 379   2          }
 380   1      
 381   1          // 计次列表绘制
 382   1          for (i = 0; i < 3; i++)
 383   1          {
 384   2              page = 2 + i * 2;
 385   2              if (i < g_lap_count)
 386   2              {
 387   3                  lap_index = g_lap_count - 1 - i;
 388   3                  lap_no = lap_index + 1;
 389   3      
 390   3                  /* 复用: NeedLapUpdate 辅助函数 */
 391   3                  if (first_draw || NeedLapUpdate(i, lap_index))
 392   3                  {
 393   4                      unsigned char lap_col = 0;
 394   4                      unsigned char base_col = 16 + 16;
 395   4                      LCD_ClearArea(page, page + 1, 0, 127);
 396   4      
 397   4                      Display_Char_8x16(page, lap_col, 'L');
 398   4                      lap_col += 8;
 399   4                      Display_Char_8x16(page, lap_col, (lap_no >= 10) ? (lap_no / 10 + '0') : ' ');
 400   4                      lap_col += 8;
 401   4                      Display_Char_8x16(page, lap_col, lap_no % 10 + '0');
 402   4      
 403   4                      Display_DrawLapTime(page, base_col, lap_index); // 复用: 绘制计次时间
 404   4                      Display_SetPrevLap(i, lap_index);               // 复用: 更新缓存
 405   4                  }
 406   3              }
 407   2              else
 408   2              {
 409   3                  if (first_draw || g_prev_lap_index[i] != 0xFF)
 410   3                  {
 411   4                      LCD_ClearArea(page, page + 1, 0, 127);
 412   4                      Display_ResetPrevLap(i); /* 复用: 重置缓存 */
 413   4                  }
 414   3              }
 415   2          }
 416   1      }
 417          
 418          void Display_LapViewPage(void)
 419          {
 420   1          unsigned char idata i, j, start_index, page, lap_no, base_col;
 421   1      
 422   1          if (g_last_screen != DISPLAY_SCREEN_LAP)
 423   1          {
 424   2              LCD_Clear();
C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 22:45:14 PAGE 8   

 425   2          }
 426   1          g_last_screen = DISPLAY_SCREEN_LAP;
 427   1      
 428   1          start_index = g_lap_view_page * 4;
 429   1      
 430   1          for (i = 0; i < 4; i++)
 431   1          {
 432   2              page = i * 2;
 433   2              if ((start_index + i) < g_lap_count)
 434   2              {
 435   3                  j = start_index + i;
 436   3                  lap_no = j + 1;
 437   3                  LCD_ClearArea(page, page + 1, 0, 127);
 438   3      
 439   3                  Display_Char_8x16(page, 0, (lap_no >= 10) ? (lap_no / 10 + '0') : ' ');
 440   3                  Display_Char_8x16(page, 8, (lap_no % 10) + '0');
 441   3                  base_col = 16 + 16;
 442   3      
 443   3                  Display_DrawLapTime(page, base_col, j); // 复用: 绘制计次时间
 444   3              }
 445   2              else
 446   2              {
 447   3                  LCD_ClearArea(page, page + 1, 0, 127);
 448   3              }
 449   2          }
 450   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2429    ----
   CONSTANT SIZE    =     80    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      34
   IDATA SIZE       =     21      17
   BIT SIZE         =      1      13
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
