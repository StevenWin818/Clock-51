C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 02:15:46 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE DISPLAY
OBJECT MODULE PLACED IN .\Objects\display.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE display.c ROM(COMPACT) OPTIMIZE(8,SPEED) PRINT(.\Listings\display.lst) T
                    -ABS(2) OBJECT(.\Objects\display.obj)

line level    source

   1          #include "display.h"
   2          #include "clock.h"
   3          #include "stopwatch.h"
   4          #include "state.h"
   5          #include <reg51.h>
   6          #include "clock.h"
   7          extern bit g_menu_cursor_visible;
   8          
   9          typedef struct {
  10              unsigned char top[16];
  11              unsigned char bottom[16];
  12          } Hanzi16;
  13          
  14          static const Hanzi16 code g_hanzi_table[] = {
  15              {   // "Áßí"
  16                  {0x24,0x24,0xA4,0xFE,0x23,0x22,0x00,0xC0,0x38,0x00,0xFF,0x00,0x08,0x10,0x60,0x00},
  17                  {0x08,0x06,0x01,0xFF,0x01,0x06,0x81,0x80,0x40,0x40,0x27,0x10,0x0C,0x03,0x00,0x00}
  18              },
  19              {   // "Ë°®"
  20                  {0x00,0x04,0x24,0x24,0x24,0x24,0x24,0xFF,0x24,0x24,0x24,0x24,0x24,0x04,0x00,0x00},
  21                  {0x21,0x21,0x11,0x09,0xFD,0x83,0x41,0x23,0x05,0x09,0x11,0x29,0x25,0x41,0x41,0x00}
  22              }
  23          };
  24          
  25          enum {
  26              HANZI_MIAO = 0,
  27              HANZI_BIAO = 1
  28          };
  29          
  30          #define DISPLAY_SCREEN_NONE      0xFF
  31          #define DISPLAY_SCREEN_HOME      0
  32          #define DISPLAY_SCREEN_STOPWATCH 2
  33          #define DISPLAY_SCREEN_LAP       2
  34          
  35          static unsigned char idata g_last_screen = DISPLAY_SCREEN_NONE;
  36          /* removed accidental global `col`/`band_offset` to avoid conflicts with local variables */
  37          static bit g_stopwatch_initialized = 0;
  38          static unsigned char idata g_prev_stop_hour = 0xFF;
  39          static unsigned char idata g_prev_stop_minute = 0xFF;
  40          static unsigned char idata g_prev_stop_second = 0xFF;
  41          static unsigned char idata g_prev_stop_decisecond = 0xFF;
  42          static unsigned char idata g_prev_lap_index[3] = {0xFF, 0xFF, 0xFF};
  43          static unsigned char idata g_prev_lap_hour[3];
  44          static unsigned char idata g_prev_lap_minute[3];
  45          static unsigned char idata g_prev_lap_second[3];
  46          static unsigned char idata g_prev_lap_decisecond[3];
  47          static unsigned char idata g_prev_menu_pos = 0xFF;
  48          
  49          static void Display_Hanzi16(unsigned char page, unsigned char col, unsigned char index) {
  50   1          unsigned char i;
  51   1          for(i = 0; i < 16; i++) {
  52   2              LCD_DrawByte(page, col + i, g_hanzi_table[index].top[i]);
  53   2              LCD_DrawByte(page + 1, col + i, g_hanzi_table[index].bottom[i]);
  54   2          }
C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 02:15:46 PAGE 2   

  55   1      }
  56          
  57          static void Display_DrawMenuCursor(unsigned char line, bit visible)
  58          {
  59   1          unsigned char base_page;
  60   1          unsigned char col;
  61   1          unsigned char total_width;
  62   1          unsigned char time_col;
  63   1          unsigned char i;
  64   1      
  65   1          // ‰∏éÂéüÈÄªËæë‰∏ÄËá¥ÔºöË°åÂè∑ 0 -> page0Ôºå1 -> page3Ôºå2 -> page6
  66   1          if (line == 0)
  67   1          {
  68   2              base_page = 0;
  69   2          }
  70   1          else if (line == 1)
  71   1          {
  72   2              base_page = 3;
  73   2          }
  74   1          else
  75   1          {
  76   2              base_page = 6;
  77   2          }
  78   1      
  79   1          // ËÆ°ÁÆó‰∏é‰∏ªÈ°µÊó∂Èó¥Â±Ö‰∏≠‰∏ÄËá¥ÁöÑËµ∑ÂßãÂàóÔºåÂπ∂Âú®ÂÖ∂Â∑¶‰æßÁïô 10 ÂÉèÁ¥†ÊîæÂÖâÊ†áÔºà‰ΩçÁΩÆ‰∏çÂè
             -òÔºâ
  80   1          {
  81   2              total_width = 16 + (8 - 1) * 12; // 100
  82   2              time_col = (128 - total_width) / 2;
  83   2              col = (time_col > 10) ? (time_col - 10) : 0;
  84   2          }
  85   1      
  86   1          if (visible)
  87   1          {
  88   2              // ‚ñ∂ ÂÆûÂøÉÂè≥‰∏âËßí
  89   2              static const unsigned char code arrow_bottom[8] = {
  90   2                  0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01};
  91   2              static const unsigned char code arrow_top[8] = {
  92   2                  0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80};
  93   2              for (i = 0; i < 8; i++)
  94   2              {
  95   3                  LCD_DrawByte(base_page, col + i, arrow_top[i]);
  96   3                  LCD_DrawByte(base_page + 1, col + i, arrow_bottom[i]);
  97   3              }
  98   2          }
  99   1          else
 100   1          {
 101   2              // Ê∏ÖÈô§ËØ•‰ΩçÁΩÆÂÖâÊ†áÔºàÂÆΩ 8 ÂàóÔºâ
 102   2              LCD_ClearArea(base_page, base_page + 1, col, col + 7);
 103   2          }
 104   1      }
 105          
 106          static void Display_Char_8x16_Custom(unsigned char page, unsigned char col, char c, bit underline)
 107          {
 108   1          unsigned char i;
 109   1          unsigned char index = GetCharIndex(c);
 110   1          unsigned char data_byte;
 111   1      
 112   1          for(i = 0; i < 8; i++) {
 113   2              data_byte = Font_8x16[index][i];
 114   2              LCD_DrawByte(page, col + i, data_byte);
 115   2      
C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 02:15:46 PAGE 3   

 116   2              data_byte = Font_8x16[index][i + 8];
 117   2              if(underline) {
 118   3                  data_byte |= 0x80;
 119   3              }
 120   2              LCD_DrawByte(page + 1, col + i, data_byte);
 121   2          }
 122   1      }
 123          
 124          static void Display_Char_16x16_Custom(unsigned char page, unsigned char col, char c, bit underline) {
 125   1          unsigned char i;
 126   1          unsigned char index = GetCharIndex(c);
 127   1          unsigned char data_byte;
 128   1      
 129   1          for(i = 0; i < 16; i++) {
 130   2              data_byte = Font_16x16[index][i];
 131   2              LCD_DrawByte(page, col + i, data_byte);
 132   2      
 133   2              data_byte = Font_16x16[index][i + 16];
 134   2              if(underline) {
 135   3                  data_byte |= 0x80;
 136   3              }
 137   2              LCD_DrawByte(page + 1, col + i, data_byte);
 138   2          }
 139   1      }
 140          
 141          void Display_Char_8x16(unsigned char page, unsigned char col, char c) {
 142   1          unsigned char i;
 143   1          unsigned char index = GetCharIndex(c);
 144   1      
 145   1          for(i = 0; i < 8; i++) {
 146   2              LCD_DrawByte(page, col + i, Font_8x16[index][i]);
 147   2          }
 148   1          for(i = 0; i < 8; i++) {
 149   2              LCD_DrawByte(page + 1, col + i, Font_8x16[index][i + 8]);
 150   2          }
 151   1      }
 152          
 153          void Display_Char_16x16(unsigned char page, unsigned char col, char c) {
 154   1          unsigned char i;
 155   1          unsigned char index = GetCharIndex(c);
 156   1      
 157   1          for(i = 0; i < 16; i++) {
 158   2              LCD_DrawByte(page, col + i, Font_16x16[index][i]);
 159   2          }
 160   1          for(i = 0; i < 16; i++) {
 161   2              LCD_DrawByte(page + 1, col + i, Font_16x16[index][i + 16]);
 162   2          }
 163   1      }
 164          
 165          void Display_Char_24x32(unsigned char page, unsigned char col, char c) {
 166   1          unsigned char i;
 167   1          unsigned char index = GetCharIndex(c);
 168   1      
 169   1          for(i = 0; i < 24; i++) {
 170   2              LCD_DrawByte(page, col + i, Font_24x32[index][i]);
 171   2          }
 172   1          for(i = 0; i < 24; i++) {
 173   2              LCD_DrawByte(page + 1, col + i, Font_24x32[index][i + 24]);
 174   2          }
 175   1          for(i = 0; i < 24; i++) {
 176   2              LCD_DrawByte(page + 2, col + i, Font_24x32[index][i + 48]);
 177   2          }
C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 02:15:46 PAGE 4   

 178   1          for(i = 0; i < 24; i++) {
 179   2              LCD_DrawByte(page + 3, col + i, Font_24x32[index][i + 72]);
 180   2          }
 181   1      }
 182          
 183          void Display_String_8x16(unsigned char page, unsigned char col, char *str) {
 184   1          while(*str) {
 185   2              Display_Char_8x16(page, col, *str);
 186   2              col += 8;
 187   2              str++;
 188   2          }
 189   1      }
 190          
 191          void Display_String_16x16(unsigned char page, unsigned char col, char *str) {
 192   1          while(*str) {
 193   2              Display_Char_16x16(page, col, *str);
 194   2              col += 16;
 195   2              str++;
 196   2          }
 197   1      }
 198          
 199          void Display_String_24x32(unsigned char page, unsigned char col, char *str) {
 200   1          while(*str) {
 201   2              Display_Char_24x32(page, col, *str);
 202   2              col += 24;
 203   2              str++;
 204   2          }
 205   1      }
 206          
 207          void Display_Number_8x16(unsigned char page, unsigned char col, unsigned int num, unsigned char digits) {
 208   1          unsigned char i;
 209   1          unsigned int divisor = 1;
 210   1          unsigned char digit;
 211   1      
 212   1          for(i = 1; i < digits; i++) {
 213   2              divisor *= 10;
 214   2          }
 215   1      
 216   1          for(i = 0; i < digits; i++) {
 217   2              digit = (num / divisor) % 10;
 218   2              Display_Char_8x16(page, col + i * 8, digit + '0');
 219   2              divisor /= 10;
 220   2          }
 221   1      }
 222          
 223          void Display_Number_16x16(unsigned char page, unsigned char col, unsigned int num, unsigned char digits) {
 224   1          unsigned char i;
 225   1          unsigned int divisor = 1;
 226   1          unsigned char digit;
 227   1      
 228   1          for(i = 1; i < digits; i++) {
 229   2              divisor *= 10;
 230   2          }
 231   1      
 232   1          for(i = 0; i < digits; i++) {
 233   2              digit = (num / divisor) % 10;
 234   2              Display_Char_16x16(page, col + i * 16, digit + '0');
 235   2              divisor /= 10;
 236   2          }
 237   1      }
 238          
 239          void Display_HomePage(void) {
C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 02:15:46 PAGE 5   

 240   1          unsigned int year_display;
 241   1          unsigned char month_display;
 242   1          unsigned char day_display;
 243   1          unsigned char total_width;
 244   1          unsigned char time_col;
 245   1          bit editing_date;
 246   1          bit editing_time;
 247   1          unsigned char date_highlight;
 248   1          unsigned char hour_display;
 249   1          unsigned char minute_display;
 250   1          unsigned char second_display;
 251   1          bit highlight_hour_tens;
 252   1          bit highlight_hour_units;
 253   1          bit highlight_minute_tens;
 254   1          bit highlight_minute_units;
 255   1          bit highlight_second_pair;
 256   1          bit menu_active;
 257   1          unsigned char page;
 258   1          unsigned char col;
 259   1          bit first_draw = (g_last_screen != DISPLAY_SCREEN_HOME);
 260   1      
 261   1          g_last_screen = DISPLAY_SCREEN_HOME;
 262   1      
 263   1          if(first_draw) {
 264   2              LCD_ClearArea(0, 7, 0, 127);
 265   2          }
 266   1      
 267   1          /* ËÆ°ÁÆóÂΩìÂâçÊòØÂê¶Â§Ñ‰∫éÁºñËæëÊó•Êúü/Êó∂Èó¥/ËèúÂçïÁöÑÁä∂ÊÄÅÔºàÁî±‰∏ªÁ®ãÂ∫èÁöÑÁ≥ªÁªüÁä∂ÊÄÅÊéßÂà∂Ôºâ 
             -*/
 268   1          editing_date = (g_system_state == STATE_DATE_SET);
 269   1          editing_time = (g_system_state == STATE_TIME_SET);
 270   1          menu_active = (g_system_state == STATE_MENU);
 271   1      
 272   1          if(editing_date) {
 273   2              year_display = g_temp_year;
 274   2              month_display = g_temp_month;
 275   2              day_display = g_temp_day;
 276   2              date_highlight = 7 - g_edit_pos;
 277   2          } else {
 278   2              year_display = g_datetime.year;
 279   2              month_display = g_datetime.month;
 280   2              day_display = g_datetime.day;
 281   2          }
 282   1      
 283   1          if(editing_time) {
 284   2              hour_display = g_temp_hour;
 285   2              minute_display = g_temp_minute;
 286   2              second_display = g_temp_second;
 287   2          } else {
 288   2              hour_display = g_datetime.hour;
 289   2              minute_display = g_datetime.minute;
 290   2              second_display = g_datetime.second;
 291   2          }
 292   1      
 293   1          highlight_hour_tens = editing_time && (g_edit_pos == 5);
 294   1          highlight_hour_units = editing_time && (g_edit_pos == 4);
 295   1          highlight_minute_tens = editing_time && (g_edit_pos == 3);
 296   1          highlight_minute_units = editing_time && (g_edit_pos == 2);
 297   1          highlight_second_pair = editing_time && (g_edit_pos == 0 || g_edit_pos == 1);
 298   1      
 299   1          /* ËèúÂçïÂÖâÊ†áÂ∞ÜÁ®çÂêéÁªòÂà∂ÔºåÊîæÂú®Êó∂Èó¥/Ê†áÁ≠æ‰πãÂêé‰ª•ÈÅøÂÖçË¢´Ë¶ÜÁõñ */
 300   1      
C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 02:15:46 PAGE 6   

 301   1          col = 24;
 302   1              Display_Char_8x16_Custom(0, col, (year_display / 1000) + '0', editing_date && date_highlight == 0)
             -;
 303   1          col += 8;
 304   1              Display_Char_8x16_Custom(0, col, ((year_display / 100) % 10) + '0', editing_date && date_highlight
             - == 1);
 305   1          col += 8;
 306   1              Display_Char_8x16_Custom(0, col, ((year_display / 10) % 10) + '0', editing_date && date_highlight 
             -== 2);
 307   1          col += 8;
 308   1              Display_Char_8x16_Custom(0, col, (year_display % 10) + '0', editing_date && date_highlight == 3);
 309   1          col += 8;
 310   1          Display_Char_8x16(0, col, '-');
 311   1          col += 8;
 312   1              Display_Char_8x16_Custom(0, col, (month_display / 10) + '0', editing_date && date_highlight == 4);
 313   1          col += 8;
 314   1              Display_Char_8x16_Custom(0, col, (month_display % 10) + '0', editing_date && date_highlight == 5);
 315   1          col += 8;
 316   1          Display_Char_8x16(0, col, '-');
 317   1          col += 8;
 318   1              Display_Char_8x16_Custom(0, col, (day_display / 10) + '0', editing_date && date_highlight == 6);
 319   1          col += 8;
 320   1              Display_Char_8x16_Custom(0, col, (day_display % 10) + '0', editing_date && date_highlight == 7);
 321   1      
 322   1          /* Êó∂Èó¥ÊòæÁ§∫Ë∑®Á¨¨2Ë°åÂíåÁ¨¨3Ë°å‰∏≠Èó¥ÊòæÁ§∫ÔºàËµ∑Âßã‰∫é page 3ÔºåÁªòÂà∂ page3/page4Ôºâ */
 323   1          page = 3; /* Ëµ∑ÂßãÈ°µ (page3/page4) */
 324   1          /* ËÆ°ÁÆóÂ±Ö‰∏≠Ëµ∑ÂßãÂàóÔºöÊØèÂ≠óÁ¨¶Ê≠•Ëøõ‰∏∫ 12ÔºåÂ≠óÁ¨¶ÂÆΩÂ∫¶Âèñ 16ÔºåÊÄªÂ≠óÁ¨¶Êï∞ 8 (HH:MM:SS) */
 325   1          {
 326   2              total_width = 16 + (8 - 1) * 12; /* 16 + 7*12 = 100 */
 327   2              col = (128 - total_width) / 2; /* Â±Ö‰∏≠Ëµ∑ÂßãÂàó */
 328   2          }
 329   1      
 330   1          /* Â∞Ü‰∏ªÈ°µÊó∂Èó¥Èó¥Ë∑ùËøõ‰∏ÄÊ≠•Áº©Â∞è‰∏∫Ê≠•Ëøõ 12ÔºàÊõ¥Á¥ßÂáë‰ΩÜÈÅøÂÖçÈáçÂè†Ôºâ */
 331   1              Display_Char_16x16_Custom(page, col, (hour_display / 10) + '0', highlight_hour_tens);
 332   1          col += 12;
 333   1              Display_Char_16x16_Custom(page, col, (hour_display % 10) + '0', highlight_hour_units);
 334   1          col += 12;
 335   1          Display_Char_16x16(page, col, ':');
 336   1          col += 12;
 337   1              Display_Char_16x16_Custom(page, col, (minute_display / 10) + '0', highlight_minute_tens);
 338   1          col += 12;
 339   1              Display_Char_16x16_Custom(page, col, (minute_display % 10) + '0', highlight_minute_units);
 340   1          col += 12;
 341   1          Display_Char_16x16(page, col, ':');
 342   1          col += 12;
 343   1              Display_Char_16x16_Custom(page, col, (second_display / 10) + '0', highlight_second_pair);
 344   1          col += 12;
 345   1              Display_Char_16x16_Custom(page, col, (second_display % 10) + '0', highlight_second_pair);
 346   1      
 347   1          /* Âú®Á¨¨ÂõõË°åÊòæÁ§∫‚ÄúÁßíË°®‚Äù‰∫åÂ≠ó */
 348   1          Display_Hanzi16(6, 48, HANZI_MIAO);
 349   1          Display_Hanzi16(6, 64, HANZI_BIAO);
 350   1      
 351   1          /* ÁÆ°ÁêÜÂπ∂ÁªòÂà∂ËèúÂçïÂÖâÊ†áÔºöÂÖàÊ∏ÖÈô§ÂÖàÂâçÂÖâÊ†áÔºàÂ¶ÇÊûúÂ≠òÂú®‰∏îËèúÂçï‰ªçÊøÄÊ¥ªÔºâÔºåÂÜçÁªòÂà∂
             -ÂΩìÂâçÂÖâÊ†á */
 352   1          if(menu_active) {
 353   2              if(g_prev_menu_pos != 0xFF && g_prev_menu_pos != g_menu_pos) {
 354   3                  Display_DrawMenuCursor(g_prev_menu_pos, 0);
 355   3              }
 356   2              if(g_menu_cursor_visible) {
 357   3                  Display_DrawMenuCursor(0, g_menu_pos == 0);
 358   3                  Display_DrawMenuCursor(1, g_menu_pos == 1);
C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 02:15:46 PAGE 7   

 359   3                  Display_DrawMenuCursor(2, g_menu_pos == 2);
 360   3              } else {
 361   3                  Display_DrawMenuCursor(0, 0);
 362   3                  Display_DrawMenuCursor(1, 0);
 363   3                  Display_DrawMenuCursor(2, 0);
 364   3              }
 365   2              g_prev_menu_pos = g_menu_pos;
 366   2          } else {
 367   2              if(g_prev_menu_pos != 0xFF) {
 368   3                  Display_DrawMenuCursor(g_prev_menu_pos, 0);
 369   3                  g_prev_menu_pos = 0xFF;
 370   3              }
 371   2          }
 372   1      }
*** WARNING C280 IN LINE 244 OF display.c: 'time_col': unreferenced local variable
 373          
 374          void Display_ResetStopwatch(void) {
 375   1          unsigned char idata i;
 376   1      
 377   1          g_stopwatch_initialized = 0;
 378   1          g_prev_stop_hour = 0xFF;
 379   1          g_prev_stop_minute = 0xFF;
 380   1          g_prev_stop_second = 0xFF;
 381   1          g_prev_stop_decisecond = 0xFF;
 382   1          for(i = 0; i < 3; i++) {
 383   2              g_prev_lap_index[i] = 0xFF;
 384   2              g_prev_lap_hour[i] = 0xFF;
 385   2              g_prev_lap_minute[i] = 0xFF;
 386   2              g_prev_lap_second[i] = 0xFF;
 387   2              g_prev_lap_decisecond[i] = 0xFF;
 388   2          }
 389   1      }
 390          
 391          void Display_StopwatchPage(void) {
 392   1          unsigned char idata hour;
 393   1          unsigned char idata min;
 394   1          unsigned char idata sec;
 395   1          unsigned char idata ds;
 396   1          unsigned char idata col;
 397   1          unsigned char idata i;
 398   1          unsigned char di;
 399   1          unsigned char idata page;
 400   1          unsigned char idata lap_index;
 401   1          unsigned char idata lap_no;
 402   1          bit first_draw = (!g_stopwatch_initialized) || (g_last_screen != DISPLAY_SCREEN_STOPWATCH);
 403   1      
 404   1          if(first_draw) {
 405   2              LCD_ClearArea(0, 7, 0, 127);
 406   2              g_stopwatch_initialized = 1;
 407   2              g_prev_stop_hour = 0xFF;
 408   2              g_prev_stop_minute = 0xFF;
 409   2              g_prev_stop_second = 0xFF;
 410   2              g_prev_stop_decisecond = 0xFF;
 411   2              for(i = 0; i < 3; i++) {
 412   3                  g_prev_lap_index[i] = 0xFF;
 413   3                  g_prev_lap_hour[i] = 0xFF;
 414   3                  g_prev_lap_minute[i] = 0xFF;
 415   3                  g_prev_lap_second[i] = 0xFF;
 416   3                  g_prev_lap_decisecond[i] = 0xFF;
 417   3              }
 418   2          }
 419   1      
C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 02:15:46 PAGE 8   

 420   1          g_last_screen = DISPLAY_SCREEN_STOPWATCH;
 421   1      
 422   1          Stopwatch_GetTime(&hour, &min, &sec, &ds);
 423   1      
 424   1          /* ÊÅ¢Â§çÁßíË°®È°µÈù¢‰∏∫Ê†áÂáÜÁ¥ßÂáëÊ≠•Ëøõ 8Ôºà8x16 Â≠ó‰ΩìÔºåÊ≠•Ëøõ 8Ôºâ‰ª•ÈÅøÂÖçÈáçÂè† */
 425   1          col = 16;
 426   1          if(first_draw || g_prev_stop_hour != hour) {
 427   2              Display_Char_8x16(0, col, hour / 10 + '0');
 428   2              Display_Char_8x16(0, col + 8, hour % 10 + '0');
 429   2              g_prev_stop_hour = hour;
 430   2          }
 431   1          /* ÂßãÁªàÁªòÂà∂Â∞èÊó∂/ÂàÜÈíüÂàÜÈöîÁ¨¶ÔºåÈÅøÂÖçÂú®ÈÉ®ÂàÜÂà∑Êñ∞Âêé‰∏¢Â§± */
 432   1          Display_Char_8x16(0, col + 16, ':');
 433   1          if(first_draw || g_prev_stop_minute != min) {
 434   2              Display_Char_8x16(0, col + 24, min / 10 + '0');
 435   2              Display_Char_8x16(0, col + 32, min % 10 + '0');
 436   2              g_prev_stop_minute = min;
 437   2          }
 438   1          /* ÂßãÁªàÁªòÂà∂ÂàÜÈíü/ÁßíÂàÜÈöîÁ¨¶ */
 439   1          Display_Char_8x16(0, col + 40, ':');
 440   1          if(first_draw || g_prev_stop_second != sec) {
 441   2              Display_Char_8x16(0, col + 48, sec / 10 + '0');
 442   2              Display_Char_8x16(0, col + 56, sec % 10 + '0');
 443   2              g_prev_stop_second = sec;
 444   2          }
 445   1          /* Âº∫Âà∂‰ΩøÁî®Ëá™ÂÆö‰πâÂÉèÁ¥†ÁÇπ‰Ωú‰∏∫Áßí‰∏éÊØ´ÁßíÁöÑÂàÜÈöîÁ¨¶ÔºàÂßãÁªàÁªòÂà∂Ôºâ */
 446   1          {
 447   2              /* Âú® col+64 Â§ÑÁªòÂà∂‰∏Ä‰∏™Â∞èÁöÑÁÇπÈòµÔºà8 Âàó x 16 Ë°åÔºâÔºå‰∏äÂçäÈ°µÊ∏ÖÁ©∫Ôºå‰∏ãÂçäÈ°µÁªòÂà∂Â
             -∞èÁÇπ */
 448   2              /* Êõ¥Â∞èÁöÑÁÇπÔºö‰∏§ÂàóÂÉèÁ¥†Ôºå‰Ωç‰∫é‰∏≠Èó¥ÔºåËßÜËßâÊõ¥Á≤æÁÆÄ */
 449   2              static const unsigned char code dot_top[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
 450   2              static const unsigned char code dot_bottom[8] = {0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00};
 451   2              for(di = 0; di < 8; di++) {
 452   3                  LCD_DrawByte(0, col + 64 + di, dot_top[di]);
 453   3                  LCD_DrawByte(1, col + 64 + di, dot_bottom[di]);
 454   3              }
 455   2          }
 456   1          if(first_draw || g_prev_stop_decisecond != ds) {
 457   2              Display_Char_8x16(0, col + 72, ds + '0');
 458   2              g_prev_stop_decisecond = ds;
 459   2          }
 460   1      
 461   1          for(i = 0; i < 3; i++) {
 462   2              page = 2 + i * 2;
 463   2              if(i < g_lap_count) {
 464   3                  lap_index = g_lap_count - 1 - i;
 465   3                  lap_no = lap_index + 1;
 466   3                  if(first_draw || g_prev_lap_index[i] != lap_index ||
 467   3                     g_prev_lap_hour[i] != g_laps[lap_index].hour ||
 468   3                     g_prev_lap_minute[i] != g_laps[lap_index].minute ||
 469   3                     g_prev_lap_second[i] != g_laps[lap_index].second ||
 470   3                     g_prev_lap_decisecond[i] != g_laps[lap_index].decisecond) {
 471   4                      unsigned char lap_col = 0;
 472   4                      unsigned char base_col = 16 + 16; /* ‰∏é‰∏ªÁßíË°®Ëµ∑ÁÇπ 16 ÂØπÈΩêÂπ∂ÂêëÂè≥Âπ≥Áßª 16 ÂàóÁî®
             -‰∫éÂ∫èÂè∑ */
 473   4                      LCD_ClearArea(page, page + 1, 0, 127);
 474   4                      /* ‰øùÁïôÂ∑¶‰æß L ÂíåÂ∫èÂè∑ */
 475   4                      Display_Char_8x16(page, lap_col, 'L');
 476   4                      lap_col += 8;
 477   4                      Display_Char_8x16(page, lap_col, (lap_no >= 10) ? (lap_no / 10 + '0') : ' ');
 478   4                      lap_col += 8;
 479   4                      Display_Char_8x16(page, lap_col, lap_no % 10 + '0');
C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 02:15:46 PAGE 9   

 480   4      
 481   4                      /* ‰ΩøÁî®‰∏é‰∏ªÁßíË°®Áõ∏ÂêåÁöÑÁõ∏ÂØπÂ∏ÉÂ±ÄÔºå‰ΩÜËµ∑ÁÇπ‰∏∫ base_col */
 482   4                      Display_Char_8x16(page, base_col + 0, g_laps[lap_index].hour / 10 + '0');
 483   4                      Display_Char_8x16(page, base_col + 8, g_laps[lap_index].hour % 10 + '0');
 484   4                      Display_Char_8x16(page, base_col + 16, ':');
 485   4                      Display_Char_8x16(page, base_col + 24, g_laps[lap_index].minute / 10 + '0');
 486   4                      Display_Char_8x16(page, base_col + 32, g_laps[lap_index].minute % 10 + '0');
 487   4                      Display_Char_8x16(page, base_col + 40, ':');
 488   4                      Display_Char_8x16(page, base_col + 48, g_laps[lap_index].second / 10 + '0');
 489   4                      Display_Char_8x16(page, base_col + 56, g_laps[lap_index].second % 10 + '0');
 490   4                      /* ÁªòÂà∂‰∏é‰∏ªÁßíË°®Áõ∏ÂêåÁöÑÁÇπÂíåÊØ´Áßí */
 491   4                      {
 492   5                          unsigned char di2;
 493   5                          for(di2 = 0; di2 < 8; di2++) {
 494   6                              LCD_DrawByte(page, base_col + 64 + di2, 0x00);
 495   6                              LCD_DrawByte(page + 1, base_col + 64 + di2, (di2 == 3 || di2 == 4) ? 0x18 : 0x00);
 496   6                          }
 497   5                          Display_Char_8x16(page, base_col + 72, g_laps[lap_index].decisecond + '0');
 498   5                      }
 499   4      
 500   4                      g_prev_lap_index[i] = lap_index;
 501   4                      g_prev_lap_hour[i] = g_laps[lap_index].hour;
 502   4                      g_prev_lap_minute[i] = g_laps[lap_index].minute;
 503   4                      g_prev_lap_second[i] = g_laps[lap_index].second;
 504   4                      g_prev_lap_decisecond[i] = g_laps[lap_index].decisecond;
 505   4                  }
 506   3              } else {
 507   3                  if(first_draw || g_prev_lap_index[i] != 0xFF) {
 508   4                      LCD_ClearArea(page, page + 1, 0, 127);
 509   4                      g_prev_lap_index[i] = 0xFF;
 510   4                      g_prev_lap_hour[i] = 0xFF;
 511   4                      g_prev_lap_minute[i] = 0xFF;
 512   4                      g_prev_lap_second[i] = 0xFF;
 513   4                      g_prev_lap_decisecond[i] = 0xFF;
 514   4                  }
 515   3              }
 516   2          }
 517   1      }
 518          
 519          void Display_LapViewPage(void) {
 520   1          unsigned char idata i;
 521   1          unsigned char idata j;
 522   1          unsigned char idata start_index;
 523   1          unsigned char idata page;
 524   1          unsigned char idata lap_no;
 525   1          unsigned char dot_col;
 526   1          unsigned char base_col;
 527   1      
 528   1          if(g_last_screen != DISPLAY_SCREEN_LAP) {
 529   2              LCD_Clear();
 530   2          }
 531   1          g_last_screen = DISPLAY_SCREEN_LAP;
 532   1      
 533   1          start_index = g_lap_view_page * 4;
 534   1      
 535   1          for(i = 0; i < 4; i++) {
 536   2              page = i * 2;
 537   2              if((start_index + i) < g_lap_count) {
 538   3                  j = start_index + i;
 539   3                  lap_no = j + 1;
 540   3                  LCD_ClearArea(page, page + 1, 0, 127);
 541   3                  /* Â∑¶‰æßÊòæÁ§∫Â∫èÂè∑ */
C51 COMPILER V9.60.7.0   DISPLAY                                                           11/15/2025 02:15:46 PAGE 10  

 542   3                  Display_Char_8x16(page, 0, (lap_no >= 10) ? (lap_no / 10 + '0') : ' ');
 543   3                  Display_Char_8x16(page, 8, (lap_no % 10) + '0');
 544   3                  /* time area: same spacing as main stopwatch, shifted right by 16 for sequence */
 545   3                  base_col = 16 + 16; /* main start(16) + lap number width(16) */
 546   3                  Display_Char_8x16(page, base_col + 0, g_laps[j].hour / 10 + '0');
 547   3                  Display_Char_8x16(page, base_col + 8, g_laps[j].hour % 10 + '0');
 548   3                  Display_Char_8x16(page, base_col + 16, ':');
 549   3                  Display_Char_8x16(page, base_col + 24, g_laps[j].minute / 10 + '0');
 550   3                  Display_Char_8x16(page, base_col + 32, g_laps[j].minute % 10 + '0');
 551   3                  Display_Char_8x16(page, base_col + 40, ':');
 552   3                  Display_Char_8x16(page, base_col + 48, g_laps[j].second / 10 + '0');
 553   3                  Display_Char_8x16(page, base_col + 56, g_laps[j].second % 10 + '0');
 554   3                  /* ÁªòÂà∂ÁÇπÂå∫ÂíåÊØ´ÁßíÔºå‰∏é‰∏ªÁïåÈù¢‰∏ÄËá¥ */
 555   3                  {
 556   4                      unsigned char di3;
 557   4                      for(di3 = 0; di3 < 8; di3++) {
 558   5                          LCD_DrawByte(page, base_col + 64 + di3, 0x00);
 559   5                          LCD_DrawByte(page + 1, base_col + 64 + di3, (di3 == 3 || di3 == 4) ? 0x18 : 0x00);
 560   5                      }
 561   4                      Display_Char_8x16(page, base_col + 72, g_laps[j].decisecond + '0');
 562   4                  }
 563   3              } else {
 564   3                  LCD_ClearArea(page, page + 1, 0, 127);
 565   3              }
 566   2          }
 567   1      }
*** WARNING C280 IN LINE 525 OF display.c: 'dot_col': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3678    ----
   CONSTANT SIZE    =     96    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      80
   IDATA SIZE       =     21      15
   BIT SIZE         =      1      13
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
