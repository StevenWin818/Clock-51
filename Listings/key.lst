C51 COMPILER V9.60.7.0   KEY                                                               11/15/2025 01:32:57 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\Objects\key.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE key.c ROM(COMPACT) OPTIMIZE(8,SPEED) PRINT(.\Listings\key.lst) TABS(2) O
                    -BJECT(.\Objects\key.obj)

line level    source

   1          #include "key.h"
   2          
   3          // 全局按键变量
   4          KeyInfo data g_key_info = {KEY_VAL_NONE, KEY_NONE, 0};
   5          
   6          // 静态变量用于消抖和状态跟踪
   7          static unsigned char last_key_val = KEY_VAL_NONE;
   8          static unsigned char debounce_count = 0;
   9          static bit key_pressed_flag = 0;
  10          static bit key_reported = 0;  // 标记按键是否已被读取
  11          static bit key_released = 0;  // 标记按键已释放
  12          
  13          // 按键初始化
  14          void Key_Init(void) {
  15   1          // P3口高4位可能被其他功能占用，只设置低4位为输入
  16   1          // 写1到对应位以设置为输入模式（51单片机准双向口特性）
  17   1          P3 |= 0x0F;  // P3.0-3设为高（输入模式）
  18   1      }
  19          
  20          // 读取当前按下的键值
  21          static unsigned char Key_ReadValue(void) {
  22   1          if(KEY1 == 0) return KEY_VAL_1;
  23   1          if(KEY2 == 0) return KEY_VAL_2;
  24   1          if(KEY3 == 0) return KEY_VAL_3;
  25   1          if(KEY4 == 0) return KEY_VAL_4;
  26   1          return KEY_VAL_NONE;
  27   1      }
  28          
  29          // 按键扫描 (在定时器中断中每10ms调用一次)
  30          void Key_Scan(void) {
  31   1          unsigned char current_key = Key_ReadValue();
  32   1          
  33   1          // 消抖处理
  34   1          if(current_key == last_key_val) {
  35   2              if(debounce_count < 3) {
  36   3                  debounce_count++;
  37   3              } else {
  38   3                  // 稳定按键状态
  39   3                  if(current_key != KEY_VAL_NONE) {
  40   4                      // 有键按下
  41   4                      if(!key_pressed_flag) {
  42   5                          // 第一次检测到按键
  43   5                          key_pressed_flag = 1;
  44   5                          key_reported = 0;  // 重置上报标志
  45   5                          g_key_info.key_val = current_key;
  46   5                          g_key_info.key_state = KEY_PRESS;
  47   5                          g_key_info.press_ticks = 0;
  48   5                      } else {
  49   5                          // 持续按下
  50   5                          g_key_info.press_ticks++;
  51   5                          if(g_key_info.press_ticks >= KEY_LONG_PRESS_TICKS) {
  52   6                              // 长按
  53   6                              if(g_key_info.key_state != KEY_LONG) {
  54   7                                  g_key_info.key_state = KEY_LONG;
C51 COMPILER V9.60.7.0   KEY                                                               11/15/2025 01:32:57 PAGE 2   

  55   7                              }
  56   6                          }
  57   5                      }
  58   4                  } else {
  59   4                      // 无键按下
  60   4                      if(key_pressed_flag) {
  61   5                          // 按键释放
  62   5                          key_pressed_flag = 0;
  63   5                          key_released = 1;  // 设置释放标志
  64   5                          // 不立即清除key_val和key_state，让GetPressed读取
  65   5                      }
  66   4                  }
  67   3              }
  68   2          } else {
  69   2              // 按键值变化，重新开始消抖
  70   2              last_key_val = current_key;
  71   2              debounce_count = 0;
  72   2          }
  73   1      }
  74          
  75          // 获取按键值并清除状态 (返回值: KEY_VAL_NONE, KEY_VAL_1~4)
  76          // 返回高4位表示是否长按，低4位表示键值
  77          unsigned char Key_GetPressed(void) {
  78   1          unsigned char result = 0;
  79   1          
  80   1          // 检测长按（优先）
  81   1          if(g_key_info.key_state == KEY_LONG && !key_reported) {
  82   2              result = g_key_info.key_val | 0x10;  // 高4位标记长按
  83   2              key_reported = 1;
  84   2          }
  85   1          // 检测短按释放
  86   1          else if(g_key_info.key_state == KEY_PRESS && key_released && !key_reported) {
  87   2              result = g_key_info.key_val;
  88   2              key_reported = 1;
  89   2          }
  90   1          
  91   1          // 清除已上报的按键
  92   1          if(key_reported && key_released) {
  93   2              g_key_info.key_val = KEY_VAL_NONE;
  94   2              g_key_info.key_state = KEY_NONE;
  95   2              g_key_info.press_ticks = 0;
  96   2              key_released = 0;
  97   2              key_reported = 0;
  98   2          }
  99   1          
 100   1          return result;
 101   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    165    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
