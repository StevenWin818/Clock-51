C51 COMPILER V9.60.7.0   BUZZER                                                            11/15/2025 22:45:14 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE BUZZER
OBJECT MODULE PLACED IN .\Objects\buzzer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE buzzer.c ROM(COMPACT) OPTIMIZE(8,SPEED) PRINT(.\Listings\buzzer.lst) TAB
                    -S(2) OBJECT(.\Objects\buzzer.obj)

line level    source

   1          #include "buzzer.h"
   2          #include "clock.h"
   3          
   4          // ===== 共享状态：在 ISR 与主线程之间传递，建议 volatile =====
   5          volatile bit g_buzzer_active = 0;
   6          // buzzer_data: 低6位 = 剩余tick(0~63)，高6位 = last_second(0~59)
   7          static volatile unsigned char buzzer_data = 0;
   8          
   9          // 工具宏：存取低/高 6 位
  10          #define BUZZ_REMAINING_GET() (buzzer_data & 0x3F)
  11          #define BUZZ_REMAINING_SET(v) (buzzer_data = (buzzer_data & 0xC0) | ((v) & 0x3F))
  12          #define BUZZ_LASTSEC_GET() ((buzzer_data >> 6) & 0x3F)
  13          #define BUZZ_LASTSEC_SET(sec) (buzzer_data = (buzzer_data & 0x3F) | (((sec) & 0x3F) << 6))
  14          
  15          // 统一启动蜂鸣器，durationTicks 以 10ms 为单位
  16          static void Buzzer_Start(unsigned char durationTicks)
  17          {
  18   1          if (durationTicks == 0)
  19   1              return;
  20   1          BUZZER = BUZZER_ON;
  21   1          g_buzzer_active = 1;
  22   1          BUZZ_REMAINING_SET(durationTicks); // 锁定时长，后续只递减，不看当前时间
  23   1      }
  24          
  25          // 初始化
  26          void Buzzer_Init(void)
  27          {
  28   1          BUZZER = BUZZER_OFF; // 初始静音
  29   1          g_buzzer_active = 0;
  30   1          buzzer_data = 0x00;     // remaining=0, last_second=0
  31   1          BUZZ_LASTSEC_SET(0x3F); // 设成无效秒，避免上电立即触发
  32   1      }
  33          
  34          // 每 10ms 在定时器 ISR 中调用一次
  35          void Buzzer_Update(void)
  36          {
  37   1          unsigned char rem;
  38   1      
  39   1          if (!g_buzzer_active)
  40   1              return;
  41   1      
  42   1          rem = BUZZ_REMAINING_GET();
  43   1          if (rem == 0)
  44   1          {
  45   2              // 容错：剩余为0但仍 active
  46   2              BUZZER = BUZZER_OFF;
  47   2              g_buzzer_active = 0;
  48   2              return;
  49   2          }
  50   1      
  51   1          rem--;
  52   1          BUZZ_REMAINING_SET(rem);
  53   1          if (rem == 0)
  54   1          {
C51 COMPILER V9.60.7.0   BUZZER                                                            11/15/2025 22:45:14 PAGE 2   

  55   2              BUZZER = BUZZER_OFF;
  56   2              g_buzzer_active = 0;
  57   2          }
  58   1      }
  59          
  60          // 通用脉冲（ticks 10ms）
  61          static void Buzzer_Pulse(unsigned char ticks)
  62          {
  63   1          if (g_datetime.year >= 2000 && g_datetime.year <= 2099 &&
  64   1              g_datetime.month >= 1 && g_datetime.month <= 12)
  65   1          {
  66   2              Buzzer_Start(ticks);
  67   2          }
  68   1      }
  69          
  70          // 100ms 短响（10 tick）
  71          void Buzzer_Short(void)
  72          {
  73   1          Buzzer_Pulse(10);
  74   1      }
  75          
  76          // 500ms 长响（50 tick）
  77          void Buzzer_Long(void)
  78          {
  79   1          Buzzer_Pulse(50);
  80   1      }
  81          
  82          // 报时触发逻辑：55~59 秒短响；0 秒长响
  83          void Buzzer_Check(void)
  84          {
  85   1          unsigned char now_sec = g_datetime.second & 0x3F;
  86   1          unsigned char last_sec = BUZZ_LASTSEC_GET();
  87   1      
  88   1          // 用 last_second 防抖，确保每秒只触发一次
  89   1          if (now_sec == last_sec)
  90   1          {
  91   2              return;
  92   2          }
  93   1          BUZZ_LASTSEC_SET(now_sec);
  94   1      
  95   1          // 59分的 55~59 秒短响（每秒一次）
  96   1          if (g_datetime.minute == 59 && now_sec >= 55 && now_sec <= 59)
  97   1          {
  98   2              Buzzer_Short();
  99   2              return;
 100   2          }
 101   1      
 102   1          // 整点：第 0 秒长响（仅一次）
 103   1          if (g_datetime.minute == 0 && now_sec == 0)
 104   1          {
 105   2              Buzzer_Long();
 106   2              return;
 107   2          }
 108   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    181    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
C51 COMPILER V9.60.7.0   BUZZER                                                            11/15/2025 22:45:14 PAGE 3   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
