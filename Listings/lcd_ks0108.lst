C51 COMPILER V9.60.7.0   LCD_KS0108                                                        11/15/2025 06:28:59 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE LCD_KS0108
OBJECT MODULE PLACED IN .\Objects\lcd_ks0108.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE lcd_ks0108.c ROM(COMPACT) OPTIMIZE(8,SPEED) PRINT(.\Listings\lcd_ks0108.
                    -lst) TABS(2) OBJECT(.\Objects\lcd_ks0108.obj)

line level    source

   1          #include "lcd_ks0108.h"
   2          
   3          // å»¶è¿Ÿå‡½æ•° - å¢åŠ å»¶è¿Ÿæ—¶é—´
   4          void LCD_Delay(void) {
   5   1          unsigned char i;
   6   1          for(i = 0; i < 10; i++);  // å¢åŠ åˆ°10
   7   1      }
   8          
   9          // helper: é€‰æ‹©å·¦å³åŠå±
  10          static void LCD_Select(unsigned char side) {
  11   1          if (side == 0) {
  12   2              LCD_CS1 = 1;
  13   2              LCD_CS2 = 0;
  14   2          } else {
  15   2              LCD_CS1 = 0;
  16   2              LCD_CS2 = 1;
  17   2          }
  18   1      }
  19          
  20          static void LCD_Deselect(void) {
  21   1          LCD_CS1 = 0;
  22   1          LCD_CS2 = 0;
  23   1      }
  24          
  25          // æ£€æŸ¥å¿™çŠ¶æ€
  26          void LCD_CheckBusy(unsigned char side) {
  27   1          unsigned char status;
  28   1          unsigned char timeout = 0;
  29   1          
  30   1          LCD_DATA = 0xFF;
  31   1          LCD_DI = 0;  // æŒ‡ä»¤
  32   1          LCD_RW = 1;  // è¯»
  33   1          LCD_Select(side);
  34   1          
  35   1          do {
  36   2              LCD_E = 1;
  37   2              LCD_Delay();
  38   2              status = LCD_DATA;
  39   2              LCD_E = 0;
  40   2              LCD_Delay();
  41   2              timeout++;
  42   2              if(timeout > 200) break;  // è¶…æ—¶é€€å‡º
  43   2          } while(status & 0x80);  // æ£€æŸ¥å¿™æ ‡å¿—
  44   1          
  45   1          LCD_Deselect();
  46   1      }
  47          
  48          // å†™å‘½ä»¤
  49          void LCD_WriteCmd(unsigned char cmd, unsigned char side) {
  50   1          LCD_CheckBusy(side);
  51   1          LCD_DI = 0;  // æŒ‡ä»¤
  52   1          LCD_RW = 0;  // å†™
  53   1          LCD_Select(side);
  54   1          LCD_DATA = cmd;
C51 COMPILER V9.60.7.0   LCD_KS0108                                                        11/15/2025 06:28:59 PAGE 2   

  55   1          LCD_E = 1;
  56   1          LCD_Delay();
  57   1          LCD_E = 0;
  58   1          LCD_Delay();
  59   1          LCD_Deselect();
  60   1      }
  61          
  62          // å†™æ•°æ®
  63          void LCD_WriteData(unsigned char dat, unsigned char side) {
  64   1          LCD_CheckBusy(side);
  65   1          LCD_DI = 1;  // æ•°æ®
  66   1          LCD_RW = 0;  // å†™
  67   1          LCD_Select(side);
  68   1          LCD_DATA = dat;
  69   1          LCD_E = 1;
  70   1          LCD_Delay();
  71   1          LCD_E = 0;
  72   1          LCD_Delay();
  73   1          LCD_Deselect();
  74   1      }
  75          
  76          /* å·²ç§»é™¤ï¼šLCD_ReadData (è¯»æ•°æ®) å®ç°
  77             è¯¥å‡½æ•°åœ¨é©±åŠ¨å¤–éƒ¨æœªè¢«è°ƒç”¨ï¼Œä¸”å†…éƒ¨å”¯ä¸€è°ƒç”¨æ¥è‡ªæ³¨é‡Šæ‰çš„ LCD_DrawPointï¼Œ
  78             å› æ­¤ç§»é™¤æ­¤å®ç°ä»¥èŠ‚çœä»£ç ç©ºé—´ã€‚ */
  79          
  80          // LCDåˆå§‹åŒ–
  81          void LCD_Init(void) {
  82   1          unsigned int i;
  83   1          
  84   1          // å¤ä½è„‰å†² - ä¸¥æ ¼æŒ‰ç…§KS0108æ—¶åº
  85   1          LCD_RST = 0;
  86   1          for(i = 0; i < 5000; i++);  // RSTä½ç”µå¹³è‡³å°‘1ms
  87   1          LCD_RST = 1;
  88   1          for(i = 0; i < 10000; i++);  // RSTé‡Šæ”¾åç­‰å¾…LCDç¨³å®š(è‡³å°‘10ms)
  89   1          
  90   1          // åˆå§‹åŒ–å·¦å³ä¸¤åŠå±
  91   1          LCD_WriteCmd(LCD_CMD_DISPLAY_ON, 0);
  92   1          LCD_WriteCmd(LCD_CMD_DISPLAY_ON, 1);
  93   1          LCD_WriteCmd(LCD_CMD_START_LINE | 0, 0);
  94   1          LCD_WriteCmd(LCD_CMD_START_LINE | 0, 1);
  95   1          
  96   1          for(i = 0; i < 1000; i++);  // é¢å¤–ç¨³å®šæ—¶é—´
  97   1          LCD_Clear();
  98   1      }
  99          
 100          // è®¾ç½®ä½ç½®
 101          void LCD_SetPos(unsigned char page, unsigned char col) {
 102   1          unsigned char side;
 103   1          
 104   1          if(col < 64) {
 105   2              side = 0;
 106   2          } else {
 107   2              side = 1;
 108   2              col -= 64;
 109   2          }
 110   1          
 111   1          // ç¡®ä¿ page å’Œ col åœ¨åˆæ³•èŒƒå›´
 112   1          if(page > 7) page = 7;
 113   1          if(col > 63) col = 63;
 114   1          
 115   1          LCD_WriteCmd(LCD_CMD_SET_X | page, side);
 116   1          LCD_WriteCmd(LCD_CMD_SET_Y | col, side);
C51 COMPILER V9.60.7.0   LCD_KS0108                                                        11/15/2025 06:28:59 PAGE 3   

 117   1      }
 118          
 119          // æ¸…å±
 120          void LCD_Clear(void) {
 121   1          unsigned char page, col;
 122   1          
 123   1          for(page = 0; page < LCD_PAGES; page++) {
 124   2              for(col = 0; col < LCD_WIDTH; col++) {
 125   3                  LCD_DrawByte(page, col, 0x00);
 126   3              }
 127   2          }
 128   1      }
 129          
 130          // æ¸…é™¤æŒ‡å®šåŒºåŸŸ
 131          void LCD_ClearArea(unsigned char page_start, unsigned char page_end, unsigned char col_start, unsigned cha
             -r col_end) {
 132   1          unsigned char page, col;
 133   1          
 134   1          for(page = page_start; page <= page_end; page++) {
 135   2              for(col = col_start; col <= col_end; col++) {
 136   3                  LCD_DrawByte(page, col, 0x00);
 137   3              }
 138   2          }
 139   1      }
 140          
 141          // åœ¨æŒ‡å®šä½ç½®ç”»ä¸€ä¸ªå­—èŠ‚
 142          void LCD_DrawByte(unsigned char page, unsigned char col, unsigned char dat) {
 143   1          LCD_SetPos(page, col);
 144   1          if(col < 64) {
 145   2              LCD_WriteData(dat, 0);
 146   2          } else {
 147   2              LCD_WriteData(dat, 1);
 148   2          }
 149   1      }
 150          
 151          /* å·²ç§»é™¤ï¼šLCD_Test æµ‹è¯•å‡½æ•°ï¼ˆå¡«å……å±å¹•ï¼‰ï¼Œè¯¥å‡½æ•°åœ¨ä¸»ç¨‹åºä¸­ä»…ä»¥æ³¨é‡Šå½¢å¼å­˜åœ¨ã
             -€‚
 152             å¦‚éœ€æµ‹è¯•ï¼Œè¯·ä¸´æ—¶æ¢å¤è¯¥å‡½æ•°æˆ–åœ¨è°ƒè¯•æ—¶ç›´æ¥ä½¿ç”¨ LCD_DrawByte å¾ªç¯ã€‚ */
 153          
 154          /*
 155          // ç”»ç‚¹(x: 0-127, y: 0-63) - æœªä½¿ç”¨ï¼Œå·²æ³¨é‡Šä»¥èŠ‚çœå†…å­˜
 156          void LCD_DrawPoint(unsigned char x, unsigned char y, unsigned char color) {
 157              unsigned char page, bit_pos, dat;
 158              unsigned char side;
 159              
 160              page = y / 8;
 161              bit_pos = y % 8;
 162              
 163              if(x < 64) {
 164                  side = 0;
 165              } else {
 166                  side = 1;
 167                  x -= 64;
 168              }
 169              
 170              LCD_WriteCmd(LCD_CMD_SET_X | page, side);
 171              LCD_WriteCmd(LCD_CMD_SET_Y | x, side);
 172              
 173              // è¯»-æ”¹-å†™
 174              LCD_ReadData(side);  // ç©ºè¯»
 175              dat = LCD_ReadData(side);
 176              
C51 COMPILER V9.60.7.0   LCD_KS0108                                                        11/15/2025 06:28:59 PAGE 4   

 177              if(color) {
 178                  dat |= (1 << bit_pos);
 179              } else {
 180                  dat &= ~(1 << bit_pos);
 181              }
 182              
 183              LCD_WriteCmd(LCD_CMD_SET_Y | x, side);
 184              LCD_WriteData(dat, side);
 185          }
 186          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    337    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
